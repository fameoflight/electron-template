import { validate, ValidationError as ClassValidatorError } from 'class-validator';
import { IdConverterService } from './services/relay/IdConverterService.js';

/**
 * Base class for all GraphQL input types
 * Provides common validation functionality
 */
export abstract class BaseInput {

  /**
   * Validate this input using class-validator decorators
   * @throws Error if validation fails with detailed error messages
   */
  async validate(): Promise<void> {
    // Step 1: Convert Relay global IDs to local database IDs (e.g., "RW1iZWRkaW5nTW9kZWw6MTIz" â†’ "123")
    this.transformRelationIds();

    // Step 2: Auto-populate undefined fields with default values from decorator metadata
    this.applyDefaultValues();

    // Step 3: Run class-validator validation on populated input
    const errors = await validate(this);

    if (errors.length > 0) {
      const messages = errors
        .map(error => this.formatValidationError(error))
        .join('; ');

      throw new Error(`Validation failed: ${messages}`);
    }
  }

  /**
   * Transform Relay global IDs to local database IDs for relation fields
   * This happens before validation so validators see the correct local IDs
   */
  private transformRelationIds(): void {
    // Get relation field names from static property (generated by template)
    const relationFields = (this.constructor as any).relationFields || [];

    for (const fieldName of relationFields) {
      const value = (this as any)[fieldName];
      if (value) {
        if (typeof value === 'string') {
          // Convert Relay global ID to local database ID
          (this as any)[fieldName] = IdConverterService.decodeId(value);
        }

        if (Array.isArray(value)) {
          // Convert array of Relay global IDs to local database IDs
          (this as any)[fieldName] = value.map((id: string) => IdConverterService.decodeId(id));
        }
      }
    }
  }

  /**
   * Apply default values to undefined fields using decorator metadata
   * This happens after ID transformation but before validation
   */
  private applyDefaultValues(): void {
    const prototype = this.constructor.prototype;
    const propertyNames = Object.getOwnPropertyNames(prototype);

    for (const propertyName of propertyNames) {
      // Skip non-field properties
      if (propertyName === 'constructor' || propertyName.startsWith('__')) continue;

      // Only apply defaults to undefined values (not null or false)
      if ((this as any)[propertyName] !== undefined) continue;

      // Get default value from decorator metadata
      const defaultValue = Reflect.getMetadata('field:default', prototype, propertyName);
      if (defaultValue !== undefined) {
        (this as any)[propertyName] = defaultValue;
      }
    }
  }

  /**
   * Format a single validation error into a readable message
   */
  private formatValidationError(error: ClassValidatorError): string {
    const constraints = error.constraints || {};
    const property = error.property;
    const messages = Object.values(constraints);

    if (messages.length === 0) {
      return `${property} is invalid`;
    }

    return `${property}: ${messages.join(', ')}`;
  }

  /**
   * Check if input is valid without throwing
   * @returns true if valid, false otherwise
   */
  async isValid(): Promise<boolean> {
    const errors = await validate(this);
    return errors.length === 0;
  }

  /**
   * Get validation errors without throwing
   * @returns Array of validation error messages
   */
  async getValidationErrors(): Promise<string[]> {
    const errors = await validate(this);
    return errors.map(error => this.formatValidationError(error));
  }

  /**
   * Create a new instance from a plain object
   * This provides a clean way to convert plain objects to proper class instances
   * with all validation methods included
   * @param data Plain object with properties to copy
   * @returns New instance of the calling class with all properties set
   */
  static fromObject<T extends BaseInput>(this: new () => T, data: Partial<T>): T {
    const instance = new this();
    Object.assign(instance, data);
    return instance;
  }
}
