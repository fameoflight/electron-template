/**
 * EmbeddingModelResolver - Generated GraphQL resolver
 *
 * ⚠️ DO NOT EDIT THIS FILE DIRECTLY ⚠️
 * This file is auto-generated from schemas/EmbeddingModel.json
 *
 * To customize:
 * 1. Extend this class in main/graphql/resolvers/EmbeddingModelResolver.ts
 * 2. Override methods as needed
 *
 */

import { Resolver, Query, Mutation, Arg, Ctx, Args, ObjectType } from 'type-graphql';
import { IsNull } from 'typeorm';
import { EmbeddingModel } from '@db/entities/EmbeddingModel.js';
import { CreateEmbeddingModelInput } from '@main/graphql/inputs/EmbeddingModelInputs.js';
import { CreateUpdateEmbeddingModelInput } from '@main/graphql/inputs/EmbeddingModelInputs.js';
import { UpdateEmbeddingModelInput } from '@main/graphql/inputs/EmbeddingModelInputs.js';
import type { GraphQLContext } from '@shared/types';
import { connectionFromArray, RelayRepository, fromGlobalIdToLocalId, FieldMutation, CustomRepository } from '@base/graphql/index.js';
import { createConnectionType, ConnectionArgs } from '@base/graphql/relay/Connection.js';
import { BaseResolver } from '@base/graphql/BaseResolver.js';

@ObjectType()
export class EmbeddingModelConnection extends createConnectionType('EmbeddingModel', EmbeddingModel) { }

@Resolver(() => EmbeddingModel)
export class EmbeddingModelResolverBase extends BaseResolver {
  protected getRepository(ctx: GraphQLContext): CustomRepository<EmbeddingModel> {
    // Entity has userId field - use ownership-aware repository with context
    return this.getOwnedRepository(EmbeddingModel, ctx);
  }

  protected get repository(): RelayRepository<EmbeddingModel> {
    // This getter is for backward compatibility - use getRepository(ctx) in new methods
    throw new Error('Use getRepository(ctx) instead of this.repository to provide user context');
  }

  // ──────────────────────────────────────────────────────────────────────────
  // Queries
  // ──────────────────────────────────────────────────────────────────────────

  /**
   * Fetch single EmbeddingModel by ID
   */
  @Query(() => EmbeddingModel, { nullable: true, description: 'Fetch EmbeddingModel by ID' })
  async embeddingModel(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<EmbeddingModel | null> {
    return await this.getRepository(ctx).findOne({ where: { id: id } });
  }

  /**
   * Fetch EmbeddingModel collection (Relay connection)
   */
  @Query(() => EmbeddingModelConnection, { description: 'Fetch EmbeddingModel collection (paginated)' })
  async embeddingModels(
    @Args(() => ConnectionArgs) args: ConnectionArgs,
    @Arg('kind', () => String, { defaultValue: 'default' }) kind: 'default' | 'all',
    @Ctx() ctx: GraphQLContext
  ): Promise<ReturnType<typeof connectionFromArray<EmbeddingModel>>> {
    const where = kind === 'default' ? { deletedAt: IsNull() } : {};
    const [items, totalCount] = await this.getRepository(ctx).findAndCount({ where });
    return connectionFromArray(items, args, totalCount);
  }

  /**
   * Fetch EmbeddingModel array (non-paginated)
   */
  @Query(() => [EmbeddingModel], { description: 'Fetch EmbeddingModel array' })
  async embeddingModelsArray(
    @Arg('kind', () => String, { defaultValue: 'default' }) kind: 'default' | 'all',
    @Ctx() ctx: GraphQLContext
  ): Promise<EmbeddingModel[]> {
    if (kind === 'all') {
      return await this.getRepository(ctx).find({ withDeleted: true });
    }
    return await this.getRepository(ctx).find();
  }

  // ──────────────────────────────────────────────────────────────────────────
  // Mutations
  // ──────────────────────────────────────────────────────────────────────────

  /**
   * Create new EmbeddingModel
   */
  @FieldMutation(CreateEmbeddingModelInput, EmbeddingModel, {
    description: 'Create new EmbeddingModel'
  })
  async createEmbeddingModel(
    input: CreateEmbeddingModelInput,
    ctx: GraphQLContext
  ): Promise<EmbeddingModel> {
    const entity = this.getRepository(ctx).create(input);
    // Auto-attach userId directly to entity (preserve constructor)
    if (ctx.user) {
      (entity).userId = ctx.user?.id;
    }
    return await this.getRepository(ctx).save(entity);
  }

  /**
   * Update existing EmbeddingModel
   */
  @FieldMutation(UpdateEmbeddingModelInput, EmbeddingModel, {
    description: 'Update existing EmbeddingModel'
  })
  async updateEmbeddingModel(
    input: UpdateEmbeddingModelInput,
    ctx: GraphQLContext
  ): Promise<EmbeddingModel> {
    // Create update data object, excluding protected fields and undefined values
    const updateData: any = {};
    const excludeFields = ['id', 'userId'];

    for (const [key, value] of Object.entries(input)) {
      if (!excludeFields.includes(key) && value !== undefined) {
        updateData[key] = value;
      }
    }

    // Use the repository's updateById method which works properly with TypeORM
    return await this.getRepository(ctx).updateById(input.id, updateData);
  }

  /**
   * Create or update EmbeddingModel (upsert)
   */
  @FieldMutation(CreateUpdateEmbeddingModelInput, EmbeddingModel, {
    description: 'Create or update EmbeddingModel'
  })
  async createUpdateEmbeddingModel(
    input: CreateUpdateEmbeddingModelInput,
    ctx: GraphQLContext
  ): Promise<EmbeddingModel> {
    if (input.id) {
      // Update existing

      // Create update data object, excluding protected fields and undefined values
      const updateData: any = {};
      const excludeFields = ['id', 'userId'];

      for (const [key, value] of Object.entries(input)) {
        if (!excludeFields.includes(key) && value !== undefined) {
          updateData[key] = value;
        }
      }

      // Use the repository's updateById method which works properly with TypeORM
      return await this.getRepository(ctx).updateById(input.id, updateData);
    } else {
      // Create new
      const { id, ...createData } = input;
      const entity = this.getRepository(ctx).create(createData);
      // Auto-attach userId directly to entity (preserve constructor)
      if (ctx.user) {
        (entity).userId = ctx.user?.id;
      }
      return await this.getRepository(ctx).save(entity);
    }
  }

  /**
   * Soft delete EmbeddingModel
   */
  @Mutation(() => Boolean, { description: 'Soft delete EmbeddingModel' })
  async destroyEmbeddingModel(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<boolean> {
    // Use the repository's softDeleteById method which handles ownership and already-deleted entities
    await this.getRepository(ctx).softDeleteById(id);
    return true;
  }

  /**
   * Hard delete EmbeddingModel
   */
  @Mutation(() => Boolean, { description: 'Hard delete EmbeddingModel (permanent)' })
  async deleteEmbeddingModel(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<boolean> {
    const entity = await this.getRepository(ctx).findOneOrFail({ where: { id: id } });


    await this.getRepository(ctx).hardDeleteById(id);
    return true;
  }

  /**
   * Restore soft-deleted EmbeddingModel
   */
  @Mutation(() => EmbeddingModel, { nullable: true, description: 'Restore soft-deleted EmbeddingModel' })
  async restoreEmbeddingModel(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<EmbeddingModel | null> {
    const entity = await this.getRepository(ctx).findOne({
      where: { id: id },
      withDeleted: true
    });

    if (!entity || !entity.deletedAt) {
      return null;
    }


    return await this.getRepository(ctx).recoverById(id);
  }
}
