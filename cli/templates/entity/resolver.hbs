/**
 * {{className}}Resolver - Generated GraphQL resolver
 *
 * ⚠️ DO NOT EDIT THIS FILE DIRECTLY ⚠️
 * This file is auto-generated from schemas/{{className}}.json
 *
 * To customize:
 * 1. Extend this class in main/graphql/resolvers/{{className}}Resolver.ts
 * 2. Override methods as needed
 *
 */

import { Resolver, Query, Mutation, Arg, Ctx, Args, ObjectType } from 'type-graphql';
import { IsNull } from 'typeorm';
import { {{className}} } from '@db/entities/{{className}}.js';
{{#unless (includes exclude "create")}}
import { Create{{className}}Input } from '@main/graphql/inputs/{{className}}Inputs.js';
{{/unless}}
{{#unless (includes exclude "createUpdate")}}
import { CreateUpdate{{className}}Input } from '@main/graphql/inputs/{{className}}Inputs.js';
{{/unless}}
import { Update{{className}}Input } from '@main/graphql/inputs/{{className}}Inputs.js';
import type { GraphQLContext } from '@shared/types';
import { connectionFromArray, RelayRepository, fromGlobalIdToLocalId } from '@base/graphql/index.js';
import { createConnectionType, ConnectionArgs } from '@base/graphql/relay/Connection.js';
import { BaseResolver } from '@base/graphql/BaseResolver.js';

@ObjectType()
export class {{className}}Connection extends createConnectionType('{{className}}', {{className}}) { }

@Resolver(() => {{className}})
export class {{className}}ResolverBase extends BaseResolver {
  protected getRepository(ctx: GraphQLContext): RelayRepository<{{className}}> {
    // Entity has userId field - use ownership-aware repository with context
    return this.getRelayRepository({{className}}, ctx);
  }

  protected get repository(): RelayRepository<{{className}}> {
    // This getter is for backward compatibility - use getRepository(ctx) in new methods
    throw new Error('Use getRepository(ctx) instead of this.repository to provide user context');
  }

  // ──────────────────────────────────────────────────────────────────────────
  // Queries
  // ──────────────────────────────────────────────────────────────────────────

{{#unless (includes exclude "single")}}
  /**
   * Fetch single {{className}} by ID
   */
  @Query(() => {{className}}, { nullable: true, description: 'Fetch {{className}} by ID' })
  async {{camelName}}(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}} | null> {
    const localId = fromGlobalIdToLocalId(id);
    return await this.getRepository(ctx).findOne({ where: { id: localId } });
  }
{{/unless}}

{{#unless (includes exclude "list")}}
  /**
   * Fetch {{className}} collection (Relay connection)
   */
  @Query(() => {{className}}Connection, { description: 'Fetch {{className}} collection (paginated)' })
  async {{pluralCamelName}}(
    @Args(() => ConnectionArgs) args: ConnectionArgs,
    @Arg('kind', () => String, { defaultValue: 'default' }) kind: 'default' | 'all',
    @Ctx() ctx: GraphQLContext
  ): Promise<ReturnType<typeof connectionFromArray<{{className}}>>> {
    const where = kind === 'default' ? { deletedAt: IsNull() } : {};
    const [items, totalCount] = await this.getRepository(ctx).findAndCount({ where });
    return connectionFromArray(items, args, totalCount);
  }
{{/unless}}

{{#unless (includes exclude "array")}}
  /**
   * Fetch {{className}} array (non-paginated)
   */
  @Query(() => [{{className}}], { description: 'Fetch {{className}} array' })
  async {{pluralCamelName}}Array(
    @Arg('kind', () => String, { defaultValue: 'default' }) kind: 'default' | 'all',
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}}[]> {
    if (kind === 'all') {
      return await this.getRepository(ctx).find({ withDeleted: true });
    }
    return await this.getRepository(ctx).find();
  }
{{/unless}}

  // ──────────────────────────────────────────────────────────────────────────
  // Mutations
  // ──────────────────────────────────────────────────────────────────────────

{{#unless (includes exclude "create")}}
  /**
   * Create new {{className}}
   */
  @Mutation(() => {{className}}, { description: 'Create new {{className}}' })
  async create{{className}}(
    @Arg('input', () => Create{{className}}Input) input: Create{{className}}Input,
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}}> {
    // Validate input using class-validator
    input = await this.validateInput(input);

    const entity = this.getRepository(ctx).create(input as any);
    // Auto-attach userId directly to entity (preserve constructor)
    (entity as any).userId = ctx.user?.id;
    return await this.getRepository(ctx).save(entity as any);
  }
{{/unless}}

{{#unless (includes exclude "update")}}
  /**
   * Update existing {{className}}
   */
  @Mutation(() => {{className}}, { description: 'Update existing {{className}}' })
  async update{{className}}(
    @Arg('input', () => Update{{className}}Input) input: Update{{className}}Input,
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}}> {
    // Validate input using class-validator
    input = await this.validateInput(input);

    const entity = await this.getRepository(ctx).findOneOrFail({ where: { id: fromGlobalIdToLocalId(input.id) } });

    // Safely assign only defined, updatable fields (excludes id, userId and undefined values)
    this.safeAssignUpdate(entity, input);
    return await this.getRepository(ctx).save(entity as any);
  }
{{/unless}}

{{#unless (includes exclude "createUpdate")}}
  /**
   * Create or update {{className}} (upsert)
   */
  @Mutation(() => {{className}}, { description: 'Create or update {{className}}' })
  async createUpdate{{className}}(
    @Arg('input', () => CreateUpdate{{className}}Input) input: CreateUpdate{{className}}Input,
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}}> {
    // Validate input using class-validator
    input = await this.validateInput(input);

    if (input.id) {
      // Update existing
      const entity = await this.getRepository(ctx).findOneOrFail({ where: { id: fromGlobalIdToLocalId(input.id) } });

      // Safely assign only defined, updatable fields (excludes id, userId and undefined values)
      this.safeAssignUpdate(entity, input);
      return await this.getRepository(ctx).save(entity as any);
    } else {
      // Create new
      const { id, ...createData } = input;
      const entity = this.getRepository(ctx).create(createData as any);
      // Auto-attach userId directly to entity (preserve constructor)
      (entity as any).userId = ctx.user?.id;
      return await this.getRepository(ctx).save(entity as any);
    }
  }
{{/unless}}

{{#unless (includes exclude "destroy")}}
  /**
   * Soft delete {{className}}
   */
  @Mutation(() => Boolean, { description: 'Soft delete {{className}}' })
  async destroy{{className}}(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<boolean> {
    // Use the repository's softDeleteById method which handles ownership and already-deleted entities
    const localId = fromGlobalIdToLocalId(id);
    await this.getRepository(ctx).softDeleteById(localId);
    return true;
  }
{{/unless}}

{{#unless (includes exclude "delete")}}
  /**
   * Hard delete {{className}}
   */
  @Mutation(() => Boolean, { description: 'Hard delete {{className}} (permanent)' })
  async delete{{className}}(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<boolean> {
    const localId = fromGlobalIdToLocalId(id);
    const entity = await this.getRepository(ctx).findOneOrFail({ where: { id: localId } });

    
    await this.getRepository(ctx).hardDeleteById(localId);
    return true;
  }
{{/unless}}

  /**
   * Restore soft-deleted {{className}}
   */
  @Mutation(() => {{className}}, { nullable: true, description: 'Restore soft-deleted {{className}}' })
  async restore{{className}}(
    @Arg('id', () => String) id: string,
    @Ctx() ctx: GraphQLContext
  ): Promise<{{className}} | null> {
    const localId = fromGlobalIdToLocalId(id);
    const entity = await this.getRepository(ctx).findOne({
      where: { id: localId },
      withDeleted: true
    });

    if (!entity || !entity.deletedAt) {
      return null;
    }

    
    return await this.getRepository(ctx).recoverById(localId);
  }
}
